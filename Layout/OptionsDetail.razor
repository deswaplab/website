@inject Web3Service _web3Service
@inject ILogger<OptionsDetail> Logger
@inject MetamaskHostProvider _metamaskHostProvider
@inject IMetamaskInterop _metamaskInterop;
@inject ToastService toastService
@inject IStringLocalizer<SharedResource> Loc
@inject Web3Service _web3Service

<div class="mx-auto flex flex-col items-center py-2 max-w-sm bg-white rounded-lg shadow dark:bg-gray-800 dark:border-gray-700">
    @if (Token is null)
    {
        <img class="rounded-t-lg"
             src="@DefaultImage"
             alt="">
    }
    else
    {
        if (!string.IsNullOrEmpty(NftUrl))
        {
            <a href="@NftUrl" target="_blank">
                <img class="rounded-t-lg"
                     src="@Token.ImageData"
                     alt="">
            </a>
        }
        else
        {
            <img class="rounded-t-lg"
                 src="@Token.ImageData"
                 alt="">
        }

        <div class="flex flex-row items-center justify-center gap-2 p-5">
            @if (Token.Exercisable())
            {
                <button type="button" class="inline-flex items-center px-3 py-2 text-sm font-medium text-center text-white bg-blue-700 rounded-lg hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800 @ExerciseButtonDisabledClass"
                        @onclick="async () => await HandleExercise(Token)"
                        disabled=@ExerciseButtonDisabled>
                    @Loc["Exercise_Stmt"]
                </button>
            }
            @if (Token.Burnable())
            {
                <button type="button" class="inline-flex items-center px-3 py-2 text-sm font-medium text-center text-white bg-blue-700 rounded-lg hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800 @BurnButtonDisabledClass"
                        @onclick="async () => await HandleBurn(Token)"
                        disabled=@BurnButtonDisabled>
                    @Loc["Burn_Stmt"]
                </button>
            }
        </div>
    }
</div>

@code {
    private string DefaultImage = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjMDAwMDAwIiB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCAzMiAzMiIgaWQ9Imljb24iIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOm5vbmU7fTwvc3R5bGU+PC9kZWZzPjx0aXRsZT5uby1pbWFnZTwvdGl0bGU+PHBhdGggZD0iTTMwLDMuNDE0MSwyOC41ODU5LDIsMiwyOC41ODU5LDMuNDE0MSwzMGwyLTJIMjZhMi4wMDI3LDIuMDAyNywwLDAsMCwyLTJWNS40MTQxWk0yNiwyNkg3LjQxNDFsNy43OTI5LTcuNzkzLDIuMzc4OCwyLjM3ODdhMiwyLDAsMCwwLDIuODI4NCwwTDIyLDE5bDQsMy45OTczWm0wLTUuODMxOC0yLjU4NTgtMi41ODU5YTIsMiwwLDAsMC0yLjgyODQsMEwxOSwxOS4xNjgybC0yLjM3Ny0yLjM3NzFMMjYsNy40MTQxWiIvPjxwYXRoIGQ9Ik02LDIyVjE5bDUtNC45OTY2LDEuMzczMywxLjM3MzMsMS40MTU5LTEuNDE2LTEuMzc1LTEuMzc1YTIsMiwwLDAsMC0yLjgyODQsMEw2LDE2LjE3MTZWNkgyMlY0SDZBMi4wMDIsMi4wMDIsMCwwLDAsNCw2VjIyWiIvPjxyZWN0IGlkPSJfVHJhbnNwYXJlbnRfUmVjdGFuZ2xlXyIgZGF0YS1uYW1lPSImbHQ7VHJhbnNwYXJlbnQgUmVjdGFuZ2xlJmd0OyIgY2xhc3M9ImNscy0xIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiLz48L3N2Zz4K";

    [Parameter]
    public string ContractAddress { get; set; } = "";

    [Parameter]
    public long TokenId { get; set; }

    [Parameter]
    public string NetworkName { get; set; } = "";

    public Network? SelectedNetwork => SupportedNetworks.GetNetwork(_metamaskHostProvider.SelectedNetworkChainId);

    public string NftUrl => SelectedNetwork is not null ? SelectedNetwork.BuildNftUrl(ContractAddress, TokenId) : "";

    public UserOptionNFT? Token { get; set; }

    protected override void OnInitialized()
    {
        _metamaskHostProvider.NetworkChanged += MetamaskHostProvider_NetworkChainIdChanged;
        _metamaskHostProvider.SelectedAccountChanged += MetamaskHostProvider_SelectedAccountChanged;
    }

    private async Task MetamaskHostProvider_SelectedAccountChanged(string account)
    {
        await InvokeAsync(() => this.StateHasChanged());
    }

    private async Task MetamaskHostProvider_NetworkChainIdChanged(long chainId)
    {
        var targetNetwork = SupportedNetworks.GetNetworkByName(NetworkName);
        if (targetNetwork is not null && targetNetwork.ChainId != chainId)
        {
            var p = new Dictionary<string, string>();
            p.Add("chainId", "0x" + Convert.ToString(targetNetwork.ChainId, 16));
            await _metamaskInterop.SendAsync(new Nethereum.JsonRpc.Client.RpcMessages.RpcRequestMessage(null, "wallet_switchEthereumChain", p));
        }

        // 发请求取图片信息，更新页面
        string metadataUri = await _web3Service.GetTokenUri(ContractAddress, TokenId);
        Token = UserOptionNFT.FromStr(chainId, ContractAddress, TokenId, metadataUri);
        await InvokeAsync(() => this.StateHasChanged());
    }

    public void Dispose()
    {
        _metamaskHostProvider.NetworkChanged -= MetamaskHostProvider_NetworkChainIdChanged;
        _metamaskHostProvider.SelectedAccountChanged -= MetamaskHostProvider_SelectedAccountChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            if (Token is null && _metamaskHostProvider.SelectedNetworkChainId > 0)
            {
                string metadataUri = await _web3Service.GetTokenUri(ContractAddress, TokenId);
                Token = UserOptionNFT.FromStr(_metamaskHostProvider.SelectedNetworkChainId, ContractAddress, TokenId, metadataUri);
                StateHasChanged();
            }
        }
    }

    private bool ExerciseButtonDisabled = false;

    private string ExerciseButtonDisabledClass => ExerciseButtonDisabled ? "cursor-not-allowed" : "";

    private async Task HandleExercise(UserOptionNFT token)
    {
        Logger.LogInformation($"start handle exercise {token.TokenId}, {token.Contract}");
        ExerciseButtonDisabled = true;
        var (payAssetAddress, payAssetAmount) = token.GetPayAsset();

        // 1. Check balance
        var userPayAssetBalance = await _web3Service.GetUserBalance(_metamaskHostProvider.SelectedAccount, payAssetAddress);
        if (userPayAssetBalance < payAssetAmount)
        {
            toastService.ShowToast(Loc["InsufficientBalanceToExercise_Stmt"], ToastLevel.Error);
            ExerciseButtonDisabled = false;
            return;
        }

        var userPayAllowance = await _web3Service.GetAllowance(_metamaskHostProvider.SelectedAccount, token.Contract, payAssetAddress);
        if (userPayAllowance < payAssetAmount)
        {
            // DO approve and wait seconds
            await _web3Service.Approve(token.Contract, payAssetAmount, payAssetAddress);
            await Task.Delay(1000);
            userPayAllowance = await _web3Service.GetAllowance(_metamaskHostProvider.SelectedAccount, token.Contract, payAssetAddress);
            if (userPayAllowance < payAssetAmount)
            {
                ExerciseButtonDisabled = false;
                toastService.ShowToast(Loc["InsufficientBalanceAfterApproveToExercise_Stmt"], ToastLevel.Error);
                return;
            }
        }
        try
        {
            var txHash = await _web3Service.ExerciseOptions(token.TokenId, token.Contract);
            Logger.LogInformation($"exercise finished, tx: {txHash}");
            toastService.ShowToast($"Token: {token.TokenId} {Loc["ExerciseSuccess_Stmt"]}", ToastLevel.Success);
        }
        catch (Nethereum.JsonRpc.Client.RpcResponseException e)
        {
            if (e.Message.Contains("User denied transaction signature"))
            {
                toastService.ShowToast(Loc["TxCancelled_Stmt"], ToastLevel.Error);
            }
        }
        finally
        {
            ExerciseButtonDisabled = false;
        }
    }

    private bool BurnButtonDisabled = false;

    private string BurnButtonDisabledClass => BurnButtonDisabled ? "cursor-not-allowed" : "";

    private async Task HandleBurn(UserOptionNFT token)
    {
        BurnButtonDisabled = true; // 弹出小狐狸期间禁止点击
        try
        {
            var txHash = await _web3Service.BurnOptions(token.TokenId, token.Contract);
            Logger.LogInformation($"burn finished, tx: {txHash}");
            toastService.ShowToast($"Token {token.TokenId} {Loc["BurnSuccess_Stmt"]}", ToastLevel.Success);
        }
        catch (Nethereum.JsonRpc.Client.RpcResponseException e)
        {
            Logger.LogInformation("burn failed");
            Logger.LogError($"{e.ToString()}, {e.Message}");
            if (e.Message.Contains("User denied transaction signature"))
            {
                toastService.ShowToast(Loc["TxCancelled_Stmt"], ToastLevel.Error);
            }
        }
        finally
        {
            BurnButtonDisabled = false;
        }
    }
}
