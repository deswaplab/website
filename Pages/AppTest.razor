@page "/app/test"
@layout AppLayout
@inject HttpClient Http
@inject ILogger<AppTest> Logger
@inject MetamaskHostProvider _metamaskHostProvider
@inject Web3Service _web3Service
@inject ToastService toastService

@using System.Text.Json.Serialization
@using System.Text.Json
@using System.Numerics;
@using Nethereum.Web3;
@using Nethereum.Util;
@using Nethereum.Contracts;

<PageTitle>My Tokens</PageTitle>

<section class="bg-gray-50 dark:bg-gray-900 my-10">
    @if (Tokens.Count > 0)
        {
            <div class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4 px-4 mx-auto lg:py-0">
            @foreach (var token in Tokens)
            {
                    <div class="flex flex-col items-center py-2 max-w-sm bg-white border border-gray-200 rounded-lg shadow dark:bg-gray-800 dark:border-gray-700">
                        <a href="@buildOpenseaTokenUrl(token.Token)" target="_blank">
                            <img class="rounded-t-lg" src="@token.Token.Metadata.ImageOriginal" alt="" />
                        </a>
                            <div class="flex flex-row items-center gap-2 p-5">
                                @if (canList(token.Token.Attributes))
                                {
                                    <a href="@buildListUrl(token.Token)" target="_blank" class="inline-flex items-center px-3 py-2 text-sm font-medium text-center text-white bg-blue-700 rounded-lg hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800">
                                        List
                                    </a>
                                }
                                    <button type="button" class="inline-flex items-center px-3 py-2 text-sm font-medium text-center text-white bg-blue-700 rounded-lg hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800 @ExerciseButtonDisabledClass"
                                        disabled=@ExerciseButtonDisabled
                                    >
                                        Exercise
                                    </button>
                                    <button type="button" class="inline-flex items-center px-3 py-2 text-sm font-medium text-center text-white bg-blue-700 rounded-lg hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800 @BurnButtonDisabledClass"
                                        disabled=@BurnButtonDisabled
                                    >
                                        Burn
                                    </button>
                            </div>
                    </div>
            }
            </div>
        }
</section>
@code {
    private bool loadingTokens = false;

    private string buildListUrl(ReservoirToken token)
    {
        var network = SupportedNetworks.GetNetwork(token.ChainId);
        return $"{network!.OpenseaHost}/{token.Contract}/{token.TokenId}/sell";
    }

    private string buildOpenseaTokenUrl(ReservoirToken token)
    {
        var network = SupportedNetworks.GetNetwork(token.ChainId);
        return $"{network!.OpenseaHost}/{token.Contract}/{token.TokenId}";
    }

    private bool canExercise(IList<ReservoirTokenAttribute> tokenAttributes)
    {
        bool inMaturityDate = false;

        foreach(var attr in tokenAttributes)
        {
            if (attr.Key == "maturityDate" && attr.Value is not null)
            {
                inMaturityDate = true; // TODO: debug purpose
                var maturityDate = DateTimeOffset.FromUnixTimeSeconds(long.Parse(attr.Value));
                var now = DateTime.Now;
                if (now >= maturityDate && now < maturityDate.AddDays(1))
                {
                    inMaturityDate = true;
                }
            }
        }
        if (inMaturityDate)
        {
            return true;
        }
        return false;
    }

    private bool canBurn(IList<ReservoirTokenAttribute> tokenAttributes)
    {
        bool afterMaturityDate = false;

        foreach(var attr in tokenAttributes)
        {
            if (attr.Key == "maturityDate" && attr.Value is not null)
            {
                var maturityDate = DateTimeOffset.FromUnixTimeSeconds(long.Parse(attr.Value));
                var now = DateTime.Now;
                if (now >= maturityDate.AddDays(1))
                {
                    afterMaturityDate = true;
                }
            }
        }
        if (afterMaturityDate)
        {
            return true;
        }
        return false;
    }

    private bool canList(IList<ReservoirTokenAttribute> tokenAttributes)
    {
        bool writerIsOwner = false;

        foreach(var attr in tokenAttributes)
        {
            if (attr.Key == "writer" && attr.Value is not null)
            {
                if (attr.Value == _metamaskHostProvider.SelectedAccount)
                {
                    writerIsOwner = true;
                }
            }
        }
        if (writerIsOwner && !canBurn(tokenAttributes) && !canExercise(tokenAttributes))
        {
            return true;
        }
        return false;
    }

    private IList<ReservoirTokenResponse> Tokens {get; set;}

    protected override async Task OnInitializedAsync()
    {
        Logger.LogInformation("init");
        await fetchTokens();
        await InvokeAsync(() => this.StateHasChanged());
    }

    private async Task fetchTokens()
    {
        string s = OptionsNFT.TestTokens;
        ReservoirTokensResponse? tokensResponse = 
                JsonSerializer.Deserialize<ReservoirTokensResponse>(s);
        IList<ReservoirTokenResponse> curTokens = [];
        if (tokensResponse is not null && tokensResponse.Tokens is not null)
        {
            var theTokens = tokensResponse!.Tokens;
            curTokens = curTokens.Concat(theTokens).ToList();
        }
        Tokens = curTokens;
        Logger.LogInformation($"fuck, {Tokens.Count}, {Tokens[0].Token.TokenId}, {Tokens[0].Token.Contract}, {Tokens[0].Token.Metadata.ImageOriginal}, {Tokens[0].Token.Attributes.Count}");
        await Task.CompletedTask;
    }

    public class ReservoirTokensResponse
    {
        [JsonPropertyName("tokens")]
        public IList<ReservoirTokenResponse> Tokens { get; set; } = [];

        [JsonPropertyName("continuation")]
        public string? Continuation { get; set; }
    }

    public class ReservoirTokenResponse
    {
        [JsonPropertyName("token")]
        public ReservoirToken? Token { get; set; }

    }
    public class ReservoirToken
    {
        [JsonPropertyName("chainId")]
        public long ChainId { get; set; }

        [JsonPropertyName("contract")]
        public string? Contract { get; set; }

        [JsonPropertyName("tokenId")]
        public string? TokenId { get; set; }

        [JsonPropertyName("name")]
        public string? Name { get; set; }

        [JsonPropertyName("metadata")]
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        public ReservoirTokenMetadata? Metadata { get; set; }

        [JsonPropertyName("attributes")]
        public IList<ReservoirTokenAttribute> Attributes { get; set; } = [];
    }

    public class ReservoirTokenMetadata
    {
        [JsonPropertyName("imageOriginal")]
        public string? ImageOriginal { get; set; }
    }

    public class ReservoirTokenAttribute
    {
        [JsonPropertyName("key")]
        public string? Key { get; set; }

        [JsonPropertyName("kind")]
        public string? Kind { get; set; }

        [JsonPropertyName("value")]
        public string? Value { get; set; }

    }

    private bool ExerciseButtonDisabled = false;

    private string ExerciseButtonDisabledClass => ExerciseButtonDisabled ? "cursor-not-allowed" : "";

    private bool BurnButtonDisabled = false;

    private string BurnButtonDisabledClass => BurnButtonDisabled ? "cursor-not-allowed" : "";

}
